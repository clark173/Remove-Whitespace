#!/usr/bin/env python2
import argparse
import os
import sys

from shutil import copyfile


FILE_ERROR = 1
EMPTY_FILE = 2
KEYBOARD_INTERRUPT = 3


def parse_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument('-t', '--trailing-only', help='Only remove trailing \
                         whitespace found at the end of a line. Note that this\
                         does not remove multiple blank spaces in a row if \
                         found.', action='store_true')
    parser.add_argument('-v', '--verbose', help='Where applicable, output more\
                         data to help with debugging.', action='store_true')
    parser.add_argument('input_file', help='Specify the filename that will be \
                         checked for unnecessary whitespace. A copy of this \
                         file will be stored as <input_file>.backup', type=str)
    return parser.parse_args()

def open_file(input_file):
    if not os.path.isabs(input_file):
        directory = os.path.dirname(os.path.realpath(__file__))
        input_file = os.path.join(directory, input_file)

    try:
        f = open(input_file, 'r')
    except IOError:
        print "Error: '%s' does not appear to be a valid file"
        print "Please try again with a valid filepath"
        sys.exit(FILE_ERROR)

    return f, input_file

def read_file(input_file):
    lines = input_file.readlines()

    if len(lines) < 1:
        print "Error: File is empty - nothing to do"
        print "Please try again with a populated file"
        sys.exit(EMPTY_FILE)

    return lines

def save_new_file():
    while True:
        try:
            new_filename = raw_input("Please enter a new filename: ")
            if os.path.isfile(new_filename):
                response = raw_input("'%s' already exists. Overwrite file? "
                                     "[y/n] " % (new_filename))
                if response.lower() == 'y':
                    return new_filename
                else:
                    continue
            else:
                return new_filename
        except KeyboardInterrupt:
            print "\nExiting script"
            sys.exit(KEYBOARD_INTERRUPT)

def copy_file(filename):
    backup = '%s.backup' % (filename)

    if os.path.isfile(backup):
        while True:
            try:
                response = raw_input("'%s' already exists. Overwrite file? "
                                     "[y/n] " % (backup))
                if response.lower() == 'y':
                    break
                elif response.lower() == 'n':
                    backup = save_new_file()
                    break
                else:
                    continue
            except KeyboardInterrupt:
                print "\nExiting script"
                sys.exit(KEYBOARD_INTERRUPT)

    copyfile(filename, backup)

def check_trailing(lines, verbose):
    line_number = 1
    output_lines = []

    for line in lines:
        stripped_line = line.replace('\n', '')

        if len(stripped_line) > 0 and stripped_line[-1].isspace():
            if verbose:
                print "Trailing whitespace on line %s" % (line_number)
            stripped_line = stripped_line.rstrip()
            output_lines.append('%s\n' % (stripped_line))
        elif len(stripped_line) > 0 and not stripped_line[-1].isspace():
            output_lines.append('%s\n' % (stripped_line))
        else:
            output_lines.append('\n')

        line_number += 1
    return output_lines

def save_file(lines, filename, verbose):
    f = open(filename, 'w')

    for line in lines:
        f.write(line)

    if verbose:
        print "File saved at '%s'" % (filename)

    f.close()

def main():
    args = parse_arguments()
    input_file, filename = open_file(args.input_file)
    lines = read_file(input_file)
    copy_file(filename)
    new_lines = check_trailing(lines, args.verbose)
    save_file(new_lines, filename, args.verbose)

if __name__ == "__main__":
    main()
